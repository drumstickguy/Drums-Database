// MUVCrackModded.cpp : Este archivo contiene la función "main". La ejecución del programa comienza y termina ahí.
// The code has been modded and cleaned up by Jazzstuff.
// safety version

#include <Windows.h>
#include <math.h>
#pragma comment(lib, "winmm.lib")
#define M_PI   3.14159265358979323846264338327950288
//typedef NTSTATUS(NTAPI* NRHEdef)(NTSTATUS, ULONG, ULONG, PULONG, ULONG, PULONG);
//typedef NTSTATUS(NTAPI* RAPdef)(ULONG, BOOLEAN, BOOLEAN, PBOOLEAN);
DWORD WINAPI CursorMove(LPVOID lpParam) {
	int x = GetSystemMetrics(0);
	int y = GetSystemMetrics(1);
	while (true) {
		SetCursorPos(rand() % x, rand() % y);
		Sleep(500);
	}
}
DWORD WINAPI SplitScreen(LPVOID lpParam) {
        HDC hdc;
        int w = GetSystemMetrics(0), h = GetSystemMetrics(1), x;
        while (true) {
              hdc = GetDC(NULL);
              BitBlt(hdc, rand() % w, 0, 100, h, hdc, rand() % w, 0, SRCCOPY);
              ReleaseDC(NULL, hdc);
        }
}
DWORD WINAPI Swirl(LPVOID lpParam) {
        HDC hdc;
        int w = GetSystemMetrics(0), h = GetSystemMetrics(1), x, y;
        float i = 0;
        int i2 = 0;
        while (true) {
              hdc = GetDC(NULL);
              BitBlt(hdc, cos(i / 4) * 20, i2 * 10 % h, w, 10, hdc, 0, i2 * 10 % h, SRCCOPY);
              BitBlt(hdc, i2 * 10%w, cos(i / 4) * 20, 10, h, hdc, i2 * 10 % w, 0, SRCCOPY);
              i++;
              i2++;
              ReleaseDC(NULL, hdc);
        }
}
DWORD WINAPI IconWave(LPVOID lpParam) {
        int w = GetSystemMetrics(0), h = GetSystemMetrics(1), x, y;
        float i = 0;
        while (true) {
              HDC hdc = GetDC(NULL);
              DrawIcon(hdc, sin(i / 63) * (w/2) + (w/2), cos(i / 64) * (h / 2) + (h / 2), LoadIcon(NULL, IDI_APPLICATION));
              DrawIcon(hdc, cos(i / 63) * (w / 2) + (w / 2), sin(i / 64) * (h / 2) + (h / 2), LoadIcon(NULL, IDI_WARNING));
              DrawIcon(hdc, tan(i / 0.99) * (w / 2) + (w / 2), sin(i/1.01) * (h / 2) + (h / 2), LoadIcon(NULL, IDI_QUESTION));
              PatBlt(hdc, rand() % w, rand() % h, 100, 100, PATCOPY);
              DrawIcon(hdc, sin(i) * (w/1.5) + (w/2), tan(-i ) * (h / 2) + (h / 2), LoadIcon(NULL, IDI_ERROR));
              i++;
              ReleaseDC(0, hdc);
              DeleteDC(hdc);
        }
}
DWORD WINAPI SetPixel1(LPVOID lpParam) {
        int w = GetSystemMetrics(0), h = GetSystemMetrics(1), x = 0, y = 0;
        float i = 0;
        while (true) {
              int fishy = rand() % 4;
              HDC hdc = GetDC(NULL);
              x++;
              if (x > w) {
                  x = 0;
                  y += 5;
              }
              if (y > h) {
                  y = 0;
                  x = 0;
              }
              SetPixel(hdc,x,y, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
              SetPixel(hdc, x, y+1, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
              SetPixel(hdc, x, y + 2, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
              SetPixel(hdc, x, y + 3, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
              SetPixel(hdc, x, y + 4, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
              i += 1;
              ReleaseDC(0, hdc);
              DeleteDC(hdc);
         }
}
VOID WINAPI sound1() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 24000, 24000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[24000 * 20] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t | t >> 6) * 10 + (t / 128);

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}
VOID WINAPI sound2() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[8000 * 20] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>((t * (t * t & t * 9 % 257 - (t ^ t * 2) | t >> 8) & ~t >> 4) * (t >> 12 & 1) & 255) / 2 + (t * ((t >> 14 & 3) + 1) * ((~t >> 9 & 3) + 1) & 127);

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}
VOID WINAPI sound3() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[8000 * 20] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t * 90 / (int(t * t / 800 & 4095) + 1));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}
VOID WINAPI sound4() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[8000 * 20] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t * t / 512 | t >> 4 | t >> 5);

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}
DWORD WINAPI FishyMessage(LPVOID lpParam) {
      while (true) {
           MessageBoxW(NULL, L"fish", L"fish", MB_OK);
           MessageBoxW(NULL, L"puarco", L"puarco", MB_OK);
      }
      return 1;
}
int CALLBACK WinMain(
	HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPSTR     lpCmdLine, int       nCmdShow
)
{
	if (MessageBoxW(NULL, L"This is a GDI Only, Do you want to run this?", L"MUVCrack.exe (better version by Jazzstuff)", MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
	{
		ExitProcess(0);
	}
	else
	{
		if (MessageBoxW(NULL, L"Are you sure? It will still move your cursor and will display flashing lights", L"F?i?n?a?l? ?W?a?r?n?i?n?g? - MUVCrackModded.exe", MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
		{
			ExitProcess(0);
		}
		else
		{
			CreateThread(0, 0, CursorMove, 0, 0, 0);
			CreateThread(0, 0, FishyMessage, 0, 0, 0);
			Sleep(1000);
			HANDLE thread1 = CreateThread(0, 0, SplitScreen, 0, 0, 0);
			//HANDLE thread1dot1 = CreateThread(0, 0, blur, 0, 0, 0);
			sound1();
			Sleep(20000);
			TerminateThread(thread1, 0);
			CloseHandle(thread1);
			InvalidateRect(0, 0, 0);
			HANDLE thread2 = CreateThread(0, 0, Swirl, 0, 0, 0);
			//HANDLE thread1dot1 = CreateThread(0, 0, blur, 0, 0, 0);
			sound2();
			Sleep(20000);
			TerminateThread(thread2, 0);
			CloseHandle(thread2);
			InvalidateRect(0, 0, 0);
			HANDLE thread3 = CreateThread(0, 0, IconWave, 0, 0, 0);
			//HANDLE thread1dot1 = CreateThread(0, 0, blur, 0, 0, 0);
			sound3();
			Sleep(20000);
			TerminateThread(thread3, 0);
			CloseHandle(thread3);
			InvalidateRect(0, 0, 0);
			HANDLE thread4 = CreateThread(0, 0, SetPixel1, 0, 0, 0);
			//HANDLE thread1dot1 = CreateThread(0, 0, blur, 0, 0, 0);
			sound4();
			Sleep(20000);
			TerminateThread(thread4, 0);
			CloseHandle(thread4);
			InvalidateRect(0, 0, 0);
		}
	}
}
